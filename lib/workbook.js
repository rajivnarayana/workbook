var fn = require("./utils");
var range = require("./range");
var cell = require("./cell");
var CELLINDEX = require("./cellindex");
var constants = require("./constants");
var parser = require('./parser');
var error = require('./error.js');
var workbookUtils = require('./workbook_utils');

function workbook(config) {

    this.auto = true; // auto-recalculate is the default.
    // planned
    //this.async = true; // enable async updates as default.

    if (typeof config === 'object') {
        if (config.hasOwnProperty("name")) { this.name = config.name; }
        if (config.hasOwnProperty("auto")) { this.auto = config.auto; }
        // planned
        //if (config.hasOwnProperty("async")) { this.async = config.async; }
    }

    // arrays to store named callbacks for events
    this.callbacks = {
        set: [],
        updated: [],
    };

    // A map for cells to variable names
    this.namedRange = {};

    // formulas/functions metadata
    this.functions = {}; // functions indexed by id
    this.functionLookup = {}; // function ids indexed by exp

    // meta-meta systems
    this.cells = [];  // cells by sheetIndex and cellIndex
    this.indirect = [];  // A list of cell indirections: generated by OFFSET and INDIRECT functions
    this.ranges = [];  // static and dynamic ranges by rangeId 
    this.rangeLookup = {};  // lookup rangeId by sheetIndex, rangeIndex
    this.dynamicranges = [];  // array of dynamic ranges
    this.graph = [];  // a graph of dependencies by cellIndex [dep, prec]

    // track metadata about worksheets
    this.sheets = []; // an array of worksheets
    this.sheetNames = []; // an array of worksheet names with same index as sheets array
    this.sheetStore = {}; // a name/value pair of worksheet names to data storage store

    // keep track of dirty fields
    this.dirty = []
}

workbook.prototype.cell = function (sheetIndex, ref) {
    var sheetName,
        sheetIndex = this.resolveSheet(sheetIndex),
        ci = workbookUtils.cellInfo(ref);

    var c = new cell(this,
        sheetIndex,
        ci.rowIndex,
        ci.colIndex);
        c.sheetName = this.sheetNames[sheetIndex];
        return c;
}
display = console.log.bind(console);
workbook.prototype.debug = function () {
    var self = this;
    this.on("set", function (sheetName, row, col, newValue, oldValue) {
        display(sheetName + " set from \"" + oldValue +
            "\" to " + '"' + newValue + '"');
    });

    this.on("updated", function (sheetIndex, row, col, newValue, oldValue) {
        display(self.sheetNames[sheetIndex] + " updated from \"" + oldValue +
            "\" to " + '"' + newValue + '"');
    });

}

workbook.prototype.expandGraph = function () {
    throw "TBD";
};


workbook.prototype.findDependents = function (sheetIndex, cell) {
    var list = [],
        cellIndex = cell.cellIndex;

    var currentItems;

    if (fn.ISARRAY(this.graph)) {

        var graph = this.graph;

        // update the dependencies in a single loop through the dependency graph.

        for (var i = 0; i < graph.length; i++) {

            var dependent = graph[i][0];
            var precedent = graph[i][1];

            // circular-reference...continue
            if (dependent.sheetIndex === cell.sheetIndex &&
                dependent.addr() === cell.addr()) {
                continue;
            }

            // check if precedent matches the cell being updated
            // or if the range of precedents matches the cell.
            if (((fn.ISCELL(precedent) &&
                precedent.sheetIndex === cell.sheetIndex &&
                precedent.addr() === cell.addr()) ||
                (fn.ISRANGE(precedent) &&
                    precedent.sheetIndex === cell.sheetIndex &&
                    precedent.hit(cell.addr())))) {


                list.push(dependent);

                // concatenate with downstream dependencies
                list = list.concat(this.findDependents(dependent.sheetIndex, dependent.cellIndex));
            }
        }

    }

    return list;
}

workbook.prototype.get = function (sheetIndex, ref) {
    var sheet;

    sheetIndex = this.resolveSheet(sheetIndex);

    return this.ref(sheetIndex, ref);
}

workbook.prototype.getValue = function (sheetIndex, row, col) {

    sheetIndex = this.resolveSheet(sheetIndex);

    var sheet = this.sheets[sheetIndex];

    switch (this.sheetStore[sheetIndex]) {
        case "col":
            if (typeof sheet[col] !== "undefined") {
                return sheet[col][row];
            }
        case "row":
            if (typeof sheet[row] !== "undefined") {
                return sheet[row][col];
            }
        default:
            return sheet[fn.ADDRESS(row + 1, col + 1, 0)];
    }
}

workbook.prototype.nameRange = function (name, ref) {
    var parts;
    if (ref.indexOf('!') > 0) {
        parts = workbookUtils.splitReference(ref);

        if (parts.length !== 2) {
            throw Error("Expect two parts in ref");
        }

        sheetIndex = this.resolveSheet(parts[0]);
        this.namedRange[name] = this.ref(sheetIndex, parts[1]);

    } else {
        throw Error("Expected format Sheet!Ref");
    }

    return this;
}


// register a callback on an event
workbook.prototype.on = function (eventName, cb) {
    if (this.callbacks.hasOwnProperty(eventName)) {
        this.callbacks[eventName].push(cb);
    } else {
        throw Error("Unknown event: " + eventName);
    }
}

workbook.prototype.populateGraph = function (dep, f) {
    // push the precedents into the graph
    var precedents = f.context.precedents;
    //Rajiv : May have to filter cells if the range is already included.
    var filteredPrecedents = precedents.filter((precedent, index) => {
        return Array.from(precedents).splice(index + 1).every(otherPrecedent => {
            return !(
                fn.ISCELL(otherPrecedent) && precedent.sheetIndex === otherPrecedent.sheetIndex && precedent.addr() === otherPrecedent.addr() 
                || fn.ISRANGE(otherPrecedent) && precedent.sheetIndex === otherPrecedent.sheetIndex && otherPrecedent.hit(precedent.addr())
            )
        })
    })

    filteredPrecedents.forEach(precedent => this.graph.push([dep, precedent]));
    // for (var i = 0; i < precedents.length; i++) {
    //     this.graph.push([dep, precedents[i]]);
    // }
}

workbook.prototype.removeNamedRange = function (name) {

    if (!this.namedRange.hasOwnProperty(name)) {
        return this; // name doesn't exist.
    }

    var ref = this.namedRange[name];

    delete this.namedRange[name];
}

workbook.prototype.range = function (sheetRef, topLeft, bottomRight) {
    var index = this.resolveSheet(sheetRef);

    if (arguments.length === 2) {
        r = this.ref(index, topLeft);
    } else if (arguments.length === 3) {
        r = new range(this, index, this.cell(index, topLeft), this.cell(index, bottomRight));
    } else {
        throw Error("Unexpected usage.");
    }

    return r;
}

workbook.prototype.recalculate = function (sheetIndex, cellIndex) {
    var fid = this.cells[sheetIndex][cellIndex].fid;
    var f = this.functions[fid];

    if (!f) {
        return error.na;
    }

    return this.run(sheetIndex, f);
}

workbook.prototype.resolveSheet = function (sheetRef) {
    var sheetIndex;
    if (fn.ISNUMBER(sheetRef)) {
        return sheetRef; // short circuit
    } else if (fn.ISTEXT(sheetRef)) { // sheet name to index
        sheetIndex = this.sheetNames.indexOf(sheetRef);
    } else if (fn.ISOBJECT(sheetRef)) { // sheet object to index
        sheetIndex = this.sheets.indexOf(sheetRef);
    }

    // ensure correct resolution
    if (typeof sheetIndex === "undefined") {
        throw Error("Sheet index is undefined");
    }

    if (sheetIndex < 0) {
        throw Error("Sheet index is negative");
    }

    return sheetIndex;

}

// Get the col and row for a cell (e.g. A1 or $A$1).
workbook.prototype.ref = function (sheetIndex, ref) {
    var result;

    if (!ref) { throw Error("ref is undefined"); }

    // handle named ranges and references that are cell objects
    if (this.namedRange.hasOwnProperty(ref)) {
        return this.namedRange[ref];
    } else if (fn.ISCELL(cell)) {
        ref = cell.addr();
    }

    if (ref.indexOf(':') >= 0) { // handle ranges
        parts = ref.split(':');
        if (parts.length !== 2) { throw Error("parts should have 2 length."); }
        result = new range(this, sheetIndex, this.ref(sheetIndex, parts[0]), this.ref(sheetIndex, parts[1]));

    } else { // handle cells

        result = this.cell(sheetIndex, ref);
    }

    return result;
}


function autoName(wb) {
    return "Sheet" + (wb.sheets.length + 1);
}

function autoSheet(store) {
    switch (store) {
        case "col":
        case "row":
            return [];
        default:
            return {}
    }
}

workbook.prototype.sheet = function (config) {
    var index = this.sheets.length, ws, name, wb = this, store = "object";


    if (config) {
        if (config.hasOwnProperty("name")) {
            name = config.name;
        } else {
            name = autoName(this);
        }

        if (config.hasOwnProperty("store")) {
            store = config.store;
        }

        if (config.hasOwnProperty("data")) {
            ws = config.data;
        } else {
            ws = autoSheet(store);
        }


    } else {
        name = autoName(this);
        ws = autoSheet();
    }

    this.sheetNames.push(name);
    this.sheets.push(ws);
    this.sheetStore[index] = store;
    this.cells[index] = [];

    return ws;

}

// ```

// set
// ---

// Set a value in a worksheet.

// This function has three forms:

// 1.  Batch Form: **set(ws, batch<sub>setobject</sub>)**
// 2.  Reference Form: **set(ws, ref, value)**
// 3.  Index Form: **set(ws, row, col, value)**

// ``` javascript

workbook.prototype.set = function () {
    var ws, wsName, ref, row, col, value, ci, sheetIndex, oldValue, exp;

    if (arguments.length < 2 || arguments.length > 4) {
        throw Error("set expects 2..4 arguments. actual: " + arguments.length);
    }

    sheetIndex = this.resolveSheet(arguments[0]);


    if (arguments.length === 2) {

        for (var key in arguments[1]) {
            this.set(sheetIndex, key, arguments[1][key]);
        }

        return;

    } else if (arguments.length === 3) {

        ref = arguments[1];
        value = arguments[2];

        // handle named ranges
        if (typeof ref === "number") {
            ref = new cell(this, sheetIndex, ref);
        } else {
            if (this.namedRange.hasOwnProperty(ref)) {
                ref = this.namedRange[ref];
            } else {
                ref = this.ref(sheetIndex, ref);
            }

            if (fn.ISRANGE(ref)) {
                ref.set(value);
                return;
            }
        }

    } else if (arguments.length === 4) {
        row = arguments[1];
        col = arguments[2];
        value = arguments[3];

        ref = new cell(this, sheetIndex, row, col);
    }

    if (typeof value === "string" && value[0] === "=") {
        exp = value;
        value = this.setFormula(sheetIndex, ref, exp);
    }

    oldValue = this.setValue(sheetIndex, ref, value);
    this.triggerEvent("set", [this.sheetNames[sheetIndex], ref, oldValue, value]);

    this.update(sheetIndex, ref);

    return this;
};
// ```

// setFormula
// ----------

// ``` javascript
workbook.prototype.setFormula = function (sheetIndex, ref, exp) {
    var ref, addr,
        f, cellIndex = ref.cellIndex;

    // run the expression
    var fun = this.run(this.sheets[sheetIndex], exp, true);
    var result = fun(fun.context);
    this.populateGraph(ref, fun);

    f = this.lookupFormulaId(exp);
    if (typeof f === "number") {
        this.cells[sheetIndex][cellIndex].fid = f;
    } else {
        throw Error("Cannot find function for exp: " + exp);
    }

    return result;
}
// ```

// setValue
// --------

// ``` javascript
// row and col expected in 0 base. first column is 0 and first row is 0.
workbook.prototype.setValue = function (sheetIndex, cell, value) {
    var col = cell.colIndex,
        row = cell.rowIndex;

    if (row >= constants.MAX_ROWS) {
        throw Error("Exceeds maximum row");
    }

    if (col >= constants.MAX_COLS) {
        throw Error("Exceeds maximum col");
    }

    var ws = this.sheets[sheetIndex], oldValue, addr;

    switch (this.sheetStore[sheetIndex]) {
        case "col":
            if (!ws[col]) { ws[col] = []; }
            oldValue = ws[col][row];
            ws[col][row] = value;
            break;
        case "row":
            if (!ws[row]) { ws[row] = []; }
            oldValue = ws[row][col]
            ws[row][col] = value;
            break;
        default:
            addr = cell.addr();
            oldValue = ws[addr];
            ws[addr] = value;
    }


    return oldValue;

}

// ```

// triggerEvent
// ------------

// Triggers event callbacks when an action is performed on a worksheet.

// ``` javascript
// invokes all of the callbacks registered by callers
workbook.prototype.triggerEvent = function (eventName, args) {
    this.callbacks[eventName].forEach(function (cb) {
        cb.apply(this, args);
    });
}
// ```

// update
// ------

// ``` javascript
workbook.prototype.update = function (sheetIndex, cell) {
    var dirtyCells = this.findDependents(sheetIndex, cell);

    if (dirtyCells) {
        for (var i = 0; i < dirtyCells.length; i++) {
            var cellIndex = dirtyCells[i].cellIndex,
                rowIndex = dirtyCells[i].rowIndex,
                colIndex = dirtyCells[i].colIndex,
                sheetIndex = dirtyCells[i].sheetIndex;

            oldValue = this.getValue(sheetIndex, rowIndex, colIndex);
            newValue = this.recalculate(sheetIndex, cellIndex);

            if (oldValue !== newValue) {

                if (fn.ISCELL(newValue) || oldValue !== newValue.valueOf()) {
                    this.set(sheetIndex,
                        rowIndex,
                        colIndex,
                        newValue.valueOf());

                    // Trigger notification on the callbacks
                    this.triggerEvent("updated",
                        [sheetIndex,
                            rowIndex,
                            colIndex,
                            newValue,
                            oldValue]);

                }
            }
        }
    }
}

// todo: make sure that formula lookup ignores leading "="
workbook.prototype.lookupFormulaId = function (exp) {
    if (typeof exp !== "string") {
        throw Error("Formula lookup key must be string");
    }

    if (exp[0] === "=") {
        exp = exp.substr(1);
    }

    if (this.functionLookup.hasOwnProperty(exp)) {
        return this.functionLookup[exp];
    }
}

workbook.prototype.run = function (sheetRef, exp, ret) {
    var f,
        context = { workbook: this, precedents: [] },
        index;

    // handle case when only 1 argument is passed to function
    if (arguments.length === 1) {

        if (typeof sheetRef !== "string") {
            throw new Error("Argument must be string if only 1 argument is passed to workbook.run");
        }

        exp = sheetRef;
        context.sheet = {};
    } else {
        index = this.resolveSheet(sheetRef);
        context.sheet = this.sheets[index];
        context.sheetName = this.sheetNames[index];
        context.sheetIndex = index;
    }


    context.range = function (topLeft, bottomRight) {
        var r = new range(context.workbook, context.sheetIndex, topLeft, bottomRight);
        if (r.dynamic) {
            this.workbook.dynamicranges.push(r);
        }
        this.precedents.push(r);
        return r;
    }

    context.ref = function () {
        var sheetName, addr, ref, parts;
        if (arguments.length === 2) {
            sheetName = arguments[0];
            addr = arguments[1];
            ref = this.workbook.ref(sheetName, addr);
        } else {
            addr = arguments[0];
            ref = this.workbook.ref(context.sheetIndex, addr);
        }

        this.precedents.push(ref);
        return ref;
    }

    if (typeof exp === "string") {

        if (this.constructor.name === "workbook") {
            f = this.lookupFormulaId(exp);

            if (!f) {
                f = workbookUtils.compile.apply(context, [exp]);

                if (exp[0] === "=") {
                    exp = exp.substr(1);
                }

                // Intentional programming chases its own tail.
                // the ref to a definition of a set of rules
                this.functions[f.id] = f;

                // index for faster access
                this.functionLookup[exp] = f.id;

            } else {
                f = this.functions[f];
            }
        } else { // always compile when constructor not workbook
            f = workbook.compile.apply(context, [exp]);
        }

    } else if (typeof exp === "function") {
        f = exp;
    } else {
        throw Error("exp expected to be string or function");
    }

    f.context = context;
    if (ret) {
        return f;
    }
    return f(context);
}

module.exports = workbook;